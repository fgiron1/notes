# CICLO DE VIDA DE  UNA CONEXIÓN CON WEBSOCKETS

## Comienzo de la conexión websocket
Las URI en el protocolo de websocket son de la siguiente forma:

```
"ws:" "//" host [ ":" port ] path [ "?" query ]
"wss:" "//" host [ ":" port ] path [ "?" query ]
```

wss significa web socket secure

Este es el ciclo de vida de una conexión con websockets:


<img src="https://assets.website-files.com/5ff66329429d880392f6cba2/617a911c0c264f7bfbe7be5f_websocket%20work.png">



***¿Cómo comienza una conexión con websockets? -> El Handshake***

WebSocket connections are established by _upgrading_ an HTTP request/response pair. A client that supports WebSockets and wants to establish a connection will send an HTTP request that includes a few required headers:

-   `Connection: Upgrade`
    -   The `Connection` header generally controls whether or not the network connection stays open after the current transaction finishes. A common value for this header is `keep-alive` to make sure the connection is persistent to allow for subsequent requests to the same server. During the WebSocket opening handshake we set to header to `Upgrade`, signaling that we want to keep the connection alive, and use it for non-HTTP requests.
-   `Upgrade: websocket`
    -   The `Upgrade` header is used by clients to ask the server to switch to one of the listed protocols, in descending preference order. We specify `websocket` here to signal that the client wants to establish a WebSocket connection.
-   `Sec-WebSocket-Key: q4xkcO32u266gldTuKaSOw==`
    -   The `Sec-WebSocket-Key` is a one-time random value (a nonce) generated by the client. The value is a randomly selected 16-byte value that has been base64-encoded.
-   `Sec-WebSocket-Version: 13`
    -   The only accepted version of the WebSocket protocol is 13. Any other version listed in this header is invalid.

PETICIÓN DE APERTURA DE UNA CONEXIÓN CON WEBSOCKETS:


```
GET ws://example.com:8181/ HTTP/1.1
Host: localhost:8181
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: q4xkcO32u266gldTuKaSOw==
```

## Sucesivos mensajes tras el handshake

Websockets es un protocolo *framed*, es decir, que un mensaje es dividido en múltiples partes, e incluido en *frames*, que además poseen más información. Aquí un breve resumen del contenido de un frame:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

#### Fin Bit

The first bit of the WebSocket header is the Fin bit. This bit is set if this frame is the last data to complete this message.

#### RSV1, RSV2, RSV3 Bits

These bits are reserved for future use.

#### opcode

Every frame has an opcode that determines how to interpret this frame’s payload data.

#### Mask

Setting this bit to 1 enables _masking_. WebSockets require that all payload be obfuscated using a random key (the mask) chosen by the client. The masking key is combined with the payload data using an XOR operation before sending data to the payload. This masking prevents caches from misinterpreting WebSocket frames as cacheable data. Why should we prevent caching of WebSocket data? Security.

During development of the WebSocket protocol, it was shown that if a compromised server is deployed, and clients connect to that server, it is possible to have intermediate proxies or infrastructure cache the responses of the compromised server so that future clients requesting that data receive the incorrect response. This attack is called _cache poisoning_, and results from the fact that we cannot control how misbehaving proxies behave in the wild. This is especially problematic when introducing a new protocol like WebSocket that has to interact with the existing infrastructure of the internet.

#### Payload len

The `Payload len` field and `Extended payload length` field are used to encode the total length of the payload data for this frame. If the payload data is small (under 126 bytes), the length is encoded in the `Payload len` field. As the payload data grows, we use the additional fields to encode the length of the payload.

#### Masking-key

As discussed with the `MASK` bit, all frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0.

#### Payload data

The `Payload data` includes arbitrary application data and any extension data that has been negotiated between the client and the server. Extensions are negotiated during the initial handshake and allow you to extend the WebSocket protocol for additional uses.


## Cerrando una conexión con websockets. El handshake de despedida

To close a WebSocket connection, a closing frame is sent (opcode `0x08`). In addition to the opcode, the close frame may contain a body that indicates the reason for closing. If either side of a connection receives a close frame, it must send a close frame in response, and no more data should be sent over the connection. Once the close frame has been received by both parties, the TCP connection is torn down. The server always initiates closing the TCP connection.